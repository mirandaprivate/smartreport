import {Builder} from '../../common/builder'
import {Exception} from '../../common/exception'
import {getLogger} from '../../common/log'
import {Impl} from '../../common/mapped_types'
import Long from 'long'

import {
    CtorType,
    decode,
    DescriptorProto,
    encode,
    EnumDescriptorProto,
    fromJson,
    Message,
    Registry,
    toJson,
} from '../../index'

import {buildFileDescriptor} from './person_descriptor'
// tslint:disable-next-line: no-wildcard-import
import * as petMock from './pet_mock'

/**
 * This protobuf message is actually generated by plugin.
 */

const FILE_DESCRIPTOR = buildFileDescriptor()

const enum PersonType {
    NPC,
    PLAYER,
}

// tslint:disable-next-line: naming-convention
export const enum _AddressField {
    HOME = 'home',
    COMPANY = 'company',
}

type AddressType = string | string
type AddressField = _AddressField
const ADDRESS: readonly _AddressField[] = [
    _AddressField.COMPANY,
    _AddressField.HOME,
]

// tslint:disable-next-line: naming-convention
export const enum _EmptyField {
    TEXT = 'text',
    NUM = 'number',
}

type EmptyType = string | number
type EmptyField = _EmptyField
const EMPTY: readonly _EmptyField[] = [
    _EmptyField.TEXT,
    _EmptyField.TEXT,
]

export interface Person extends Message {
    readonly name: string
    readonly age: number
    readonly height: number
    readonly asset: Long
    readonly loc?: Location
    readonly type: PersonType
    readonly favorite: readonly string[]
    readonly pet?: petMock.Animal
    readonly relations: Map<string, string>
    readonly key: Long
    readonly home?: string
    readonly company?: string
    readonly text?: string
    readonly num?: number
    readonly scores: readonly Long[]
    getAddress(): readonly [AddressType, AddressField] | undefined
    getEmpty(): readonly [EmptyType, EmptyField] | undefined
    encode(): Readonly<Uint8Array> | Exception
    toJson(indent?: string | number): string
}

class PersonImpl implements Impl<Person> {
    public name = ''
    public age = 0
    public height = 0
    public asset = Long.fromNumber(0, true)
    public loc?: Location
    public type: PersonType = 0
    public favorite: readonly string[] = []
    public pet?: petMock.Animal
    public relations = new Map<string, string>()
    public key = Long.fromNumber(0)
    public scores: readonly Long[] = []

    public protobufInternal = {
        // FILE_DESCRIPTOR can build from string bytes by plugin
        fileDescriptorProto: FILE_DESCRIPTOR,
        messageName: '.base.ts.common.proto.Person',
        registry: REGISTRY,
    }

    public home?: string
    public company?: string
    public text?: string
    public num?: number

    public getAddress(): readonly [AddressType, AddressField] | undefined {
        for (const field of ADDRESS) {
            const value = Reflect.get(this, field)
            if (value !== undefined)
                return [field, value]
        }
        return
    }

    public getEmpty(): readonly [EmptyType, EmptyField] | undefined {
        for (const field of EMPTY) {
            const value = Reflect.get(this, field)
            if (value !== undefined)
                return [field, value]
        }
        return
    }

    public encode(): Readonly<Uint8Array> | Exception {
        return encode(this)
    }

    public toJson(indent: string | number = ''): string {
        return toJson(this, indent)
    }

    public clone(): Message {
        return this
    }
}

export class PersonBuilder extends Builder<Person, PersonImpl> {
    public constructor(obj?: Readonly<Person>) {
        const impl = new PersonImpl()
        if (obj)
            PersonBuilder.shallowCopy(impl, obj)
        super(impl)
    }

    public name(name: string): this {
        this.getImpl().name = name
        return this
    }

    public age(age: number): this {
        this.getImpl().age = age
        return this
    }

    public height(height: number): this {
        this.getImpl().height = height
        return this
    }

    public asset(asset: Long): this {
        this.getImpl().asset = asset
        return this
    }

    public loc(loc: Location): this {
        this.getImpl().loc = loc
        return this
    }

    public type(type: PersonType): this {
        this.getImpl().type = type
        return this
    }

    public favorite(favorite: readonly string[]): this {
        this.getImpl().favorite = favorite
        return this
    }

    public pet(pet: petMock.Animal): this {
        this.getImpl().pet = pet
        return this
    }

    public relations(relations: Map<string, string>): this {
        this.getImpl().relations = relations
        return this
    }

    public key(key: Long): this {
        this.getImpl().key = key
        return this
    }

    public address(type: AddressType, field: AddressField): this {
        ADDRESS.forEach((f: string): void => {
            Reflect.deleteProperty(this.getImpl(), f)
        })
        Reflect.set(this.getImpl(), field, type)
        return this
    }

    public empty(type: EmptyType, field: EmptyField): this {
        EMPTY.forEach((f: string): void => {
            Reflect.deleteProperty(this.getImpl(), f)
        })
        Reflect.set(this.getImpl(), field, type)
        return this
    }

    public scores(scores: readonly Long[]): this {
        this.getImpl().scores = scores
        return this
    }

    public decode(bin: Readonly<Uint8Array>): this {
        const err = decode(bin, this.getImpl())
        if (err !== undefined)
            getLogger().error(err.message)
        return this
    }

    public fromJson(content: string): this {
        // tslint:disable-next-line: no-object
        Object.assign(this.getImpl(), fromJson(content, this.getImpl()))
        return this
    }

    protected get dda(): readonly string[] {
        return PersonBuilder.__DDA_PROPS__
    }
    protected static readonly __DDA_PROPS__: readonly string[] = []
}

export function isPerson(obj: unknown): obj is Person {
    return obj instanceof PersonImpl
}

export interface Location extends Message {
    readonly x: number
    readonly y: number
    encode(): Readonly<Uint8Array> | Exception
    toJson(indent?: string | number): string
}

class LocationImpl implements Impl<Location> {
    public x = 0
    public y = 0

    public protobufInternal = {
        fileDescriptorProto: FILE_DESCRIPTOR,
        messageName: '.base.ts.common.proto.Location',
        registry: REGISTRY,
    }

    public encode(): Readonly<Uint8Array> | Exception {
        return encode(this)
    }

    public toJson(indent: string | number = ''): string {
        return toJson(this, indent)
    }

    public clone(): Message {
        return this
    }
}

export class LocationBuilder extends Builder<Location, LocationImpl> {
    public constructor(obj?: Readonly<Location>) {
        const impl = new LocationImpl()
        if (obj)
            LocationBuilder.shallowCopy(impl, obj)
        super(impl)
    }

    public x(x: number): this {
        this.getImpl().x = x
        return this
    }

    public y(y: number): this {
        this.getImpl().y = y
        return this
    }

    public decode(bin: Readonly<Uint8Array>): this {
        const err = decode(bin, this.getImpl())
        if (err !== undefined)
            getLogger().error(err.message)
        return this
    }

    public fromJson(content: string): this {
        // tslint:disable-next-line: no-object
        Object.assign(this.getImpl(), fromJson(content, this.getImpl()))
        return this
    }

    protected get dda(): readonly string[] {
        return LocationBuilder.__DDA_PROPS__
    }
    protected static readonly __DDA_PROPS__: readonly string[] = []
}

export function isLocation(obj: unknown): obj is Location {
    return obj instanceof LocationImpl
}

export const REGISTRY = registryInit()

function registryInit(): Readonly<Registry> {
    const registry = new Registry()
    registry.putFile(FILE_DESCRIPTOR)
    registry.putConstructor('.base.ts.common.proto.Person', PersonBuilder)
    registry.putConstructor('.base.ts.common.proto.Location', LocationBuilder)
    const animalRegistry = petMock.REGISTRY
    animalRegistry.getAllMessage().forEach((
        d: DescriptorProto,
        name: string,
    ): void => {
        registry.getAllMessage().set(name, d)
    })
    animalRegistry.getAllConstructor().forEach((
        obj: CtorType,
        name: string,
    ): void => {
        registry.putConstructor(name, obj)
    })
    animalRegistry.getAllEnum().forEach((
        d: EnumDescriptorProto,
        name: string,
    ): void => {
        registry.getAllEnum().set(name, d)
    })
    return registry
}
